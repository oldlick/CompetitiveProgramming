{
  "vector": {
    "prefix": "vin",
    "body": [
      "vector<ll> $1($2);",
      "REP(i,$2) cin>>$1[i];",
    ],
    "description": "vector<ll>"
  },
  "vout": {
    "prefix": "vout",
    "body": [
      "cout << \"$1: \"; REP(i,(signed)$1.size()) cout<<$1[i]<<\" \"; cout << endl; //----------cout----------//",
    ],
    "description": "debug vector<>"
  },
  "ll": {
    "prefix": "lin",
    "body": [
      "ll $1; cin>>$1;",
    ],
    "description": "long long"
  },
  "lout": {
    "prefix": "lout",
    "body": [
      "cout<<\"$1: \"<<$1<<endl; //----------cout----------//",
    ],
    "description": "debug vector<>"
  },
  "BinarySearch": {
    "prefix": "bin",
    "body": [
      "template <typename T,typename U> bool isOk(U data,T key){",
      "  if(data<key)return true; //data is ok",
      "  else return false;",
      "}",
      "template <typename T,typename U> long long binSearch(vector<T> &a,U key){",
      "  long long ok=-1;",
      "  long long ng=a.size();",
      "",
      "  while(abs(ok-ng)>1){",
      "    long long mid=(ok+ng)/2;",
      "    if(isOk(a[mid],key))ok=mid;",
      "    else ng=mid;",
      "  }",
      "  return ok;",
      "}"
    ],
    "description": ""
  },
  "UnionFind": {
    "prefix": "UnionFind",
    "body": [
      "class UnionFind {",
      "public:",
      "  vector<long long> par; // par[i]:iの親の番号　(例) par[3] = 2 : 3の親が2",
      "  vector<long long> siz; // siz[i]:iのサイズ　　(例) siz[3] = 2 : 3のサイズが2",
      "  UnionFind(long long N) : par(N),siz(N,1LL) { //最初は全てが根であるとして初期化",
      "    for(int i = 0; i < N; i++) par[i] = i;",
      "  }",
      "  long long root(long long x) { // データxが属する木の根を再帰で得る：root(x) = {xの木の根}",
      "    if (par[x] == x) return x;",
      "    return par[x] = root(par[x]);",
      "  }",
      "  bool unite(long long x, long long y) { // xとyの木を併合",
      "    x = root(x); //xの根をrx",
      "    y = root(y); //yの根をry",
      "    if (x == y) return false; //xとyの根が同じ(=同じ木にある)時はそのまま",
      "    if (siz[x] < siz[y]) swap(x , y);",
      "    siz[x] += siz[y];",
      "    par[y] = x; //xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける",
      "    return true;",
      "  }",
      "  bool same(int x, int y) { // 2つのデータx, yが属する木が同じならtrueを返す",
      "    return root(x) == root(y);",
      "  }",
      "  long long size(long long x) { // 素集合のサイズ",
      "    return siz[root(x)];",
      "  }",
      "};"
    ],
    "description": ""
  },
  "Dag": {
    "prefix": "dag",
    "body": [
      "class Dag {",
      "public:",
      "  vector<vector<long long>> g;",
      "  vector<long long> inCnt;",
      "  vector<long long> sorted;",
      "  bool sortedF=false;",
      "  Dag(long long N) : g(N),inCnt(N){",
      "  }",
      "  void input(long long x,long long y){",
      "    g[x].push_back(y);",
      "    inCnt[y]++;",
      "  }",
      "  bool tpSort(){",
      "    vector<long long> tmp=inCnt;",
      "    deque<long long> dq;",
      "    vector<long long> ans;",
      "    for(int i=0;i<(int)g.size();i++)if(tmp[i]==0)dq.push_back(i);",
      "    while(dq.size()!=0){",
      "      long long v=dq.front();",
      "      dq.pop_front();",
      "      ans.push_back(v);",
      "      for(auto &it:g[v]){",
      "          tmp[it]--;",
      "          if(tmp[it]==0)dq.push_back(it);",
      "      }",
      "    }",
      "    sorted.swap(ans);",
      "    sortedF=true;",
      "    return sorted.size()==g.size();",
      "  }",
      "  long long longest(){",
      "    if(sortedF==false)tpSort();",
      "    vector<long long> dp(g.size(),0);",
      "    long long res=0;",
      "    for(auto &it1:sorted){",
      "      for(auto &it2:g[it1]){",
      "          dp[it2]=dp[it2]>dp[it1]+1 ? dp[it2] : dp[it1]+1;",
      "      }",
      "      res=res>dp[it1] ? res : dp[it1];",
      "    }",
      "    return res;",
      "  }",
      "};"
    ],
    "description": ""
  },
  "moding": {
    "prefix": "mint",
    "body": [
      "const int mod = 1000000007;",
      "class mint {",
      "  long long x;",
      "public:",
      "  mint(long long x=0) : x((x%mod+mod)%mod) {}",
      "  mint operator-() const { ",
      "    return mint(-x);",
      "  }",
      "  mint& operator+=(const mint& a) {",
      "    if ((x += a.x) >= mod) x -= mod;",
      "    return *this;",
      "  }",
      "  mint& operator-=(const mint& a) {",
      "    if ((x += mod-a.x) >= mod) x -= mod;",
      "    return *this;",
      "  }",
      "  mint& operator*=(const  mint& a) {",
      "    (x *= a.x) %= mod;",
      "    return *this;",
      "  }",
      "  mint operator+(const mint& a) const {",
      "    mint res(*this);",
      "    return res+=a;",
      "  }",
      "  mint operator-(const mint& a) const {",
      "    mint res(*this);",
      "    return res-=a;",
      "  }",
      "  mint operator*(const mint& a) const {",
      "    mint res(*this);",
      "    return res*=a;",
      "  }",
      "  mint pow(long long t) const {",
      "    if (!t) return 1;",
      "    mint a = pow(t>>1);",
      "    a *= a;",
      "    if (t&1) a *= *this;",
      "    return a;",
      "  }",
      "  // for prime mod",
      "  mint inv() const {",
      "    return pow(mod-2);",
      "  }",
      "  mint& operator/=(const mint& a) {",
      "    return (*this) *= a.inv();",
      "  }",
      "  mint operator/(const mint& a) const {",
      "    mint res(*this);",
      "    return res/=a;",
      "  }",
      "  friend ostream& operator<<(ostream& os, const mint& m){",
      "    os << m.x;",
      "    return os;",
      "  }",
      "};"
    ],
    "description": ""
  },
  "combination": {
    "prefix": "com",
    "body": [
      "struct combination {",
      "  vector<mint> fact, ifact;",
      "  combination(int n):fact(n+1),ifact(n+1) {",
      "    assert(n < mod);",
      "    fact[0] = 1;",
      "    for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;",
      "    ifact[n] = fact[n].inv();",
      "    for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;",
      "  }",
      "  mint operator()(int n, int k) {",
      "    if (k < 0 || k > n) return 0;",
      "    return fact[n]*ifact[k]*ifact[n-k];",
      "  }",
      "};"
    ],
    "description": ""
  },
  "SegTree(RmQ)": {
    "prefix": "SegTree",
    "body": [
      "template <typename X>",
      "struct SegTree {",
      "  using FX = function<X(X, X)>; // X•X -> X となる関数の型",
      "  int n;",
      "  FX fx;",
      "  const X ex;",
      "  vector<X> dat;",
      "  SegTree(int n_, FX fx_, X ex_) : n(), fx(fx_), ex(ex_), dat(n_ * 4, ex_) {",
      "    int x = 1;",
      "    while (n_ > x) {",
      "      x *= 2;",
      "    }",
      "    n = x;",
      "  }",
      "  void set(int i, X x) { dat[i + n - 1] = x; }",
      "  void build() {",
      "    for (int k = n - 2; k >= 0; k--) dat[k] = fx(dat[2 * k + 1], dat[2 * k + 2]);",
      "  }",
      "  void update(int i, X x) {",
      "    i += n - 1;",
      "    dat[i] = x;",
      "    while (i > 0) {",
      "      i = (i - 1) / 2;  // parent",
      "      dat[i] = fx(dat[i * 2 + 1], dat[i * 2 + 2]);",
      "    }",
      "  }",
      "  //query(a,b):[a,b)",
      "  X query(int a, int b) { return query_sub(a, b, 0, 0, n); }",
      "  X query_sub(int a, int b, int k, int l, int r) {",
      "    if (r <= a || b <= l) {",
      "      return ex;",
      "    } else if (a <= l && r <= b) {",
      "      return dat[k];",
      "    } else {",
      "      X vl = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);",
      "      X vr = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);",
      "      return fx(vl, vr);",
      "    }",
      "  }",
      "};",
      "auto fx = [](ll x1, ll x2) -> ll { return min(x1, x2); };",
      "ll ex = numeric_limits<ll>::max();",
      "SegTree<ll> rmq(n, fx, ex);",
      "rep(i,n)rmq.set(i,tmp);",
      "rmq.build();",
    ],
    "description": ""
  },
  "SegTreeLazy(RmQ)": {
    "prefix": "SegTreeLazy",
    "body": [
        "/* SegTreeLazy<X,M>(n,fx,fa,fm,ex,em): モノイド(集合X, 二項演算fx,fa,fm, 単位元ex,em)についてサイズnで構築",
        "    set(int i, X x), build(): i番目の要素をxにセット。まとめてセグ木を構築する。O(n)",
        "    update(a,b,x): a-b 番目の要素を x に更新。O(log(n))",
        "    query(a,b):  [a,b) 全てにfxを作用させた値を取得。O(log(n))",
        "*/",
        "template <typename X, typename M>",
        "struct SegTreeLazy {",
        "    using FX = function<X(X, X)>;",
        "    using FA = function<X(X, M)>;",
        "    using FM = function<M(M, M)>;",
        "    int n;",
        "    FX fx;",
        "    FA fa;",
        "    FM fm;",
        "    const X ex;",
        "    const M em;",
        "    vector<X> dat;",
        "    vector<M> lazy;",
        "    SegTreeLazy(int n_, FX fx_, FA fa_, FM fm_, X ex_, M em_)",
        "        : n(), fx(fx_), fa(fa_), fm(fm_), ex(ex_), em(em_), dat(n_ * 4, ex), lazy(n_ * 4, em) {",
        "        int x = 1;",
        "        while (n_ > x) x *= 2;",
        "        n = x;",
        "    }",
        "    void set(int i, X x) { dat[i + n - 1] = x; }",
        "    void build() {",
        "        for (int k = n - 2; k >= 0; k--) dat[k] = fx(dat[2 * k + 1], dat[2 * k + 2]);",
        "    }",
        "    /* lazy eval */",
        "    void eval(int k) {",
        "        if (lazy[k] == em) return;  // 更新するものが無ければ終了",
        "        if (k < n - 1) {            // 葉でなければ子に伝搬",
        "            lazy[k * 2 + 1] = fm(lazy[k * 2 + 1], lazy[k]);",
        "            lazy[k * 2 + 2] = fm(lazy[k * 2 + 2], lazy[k]);",
        "        }",
        "        // 自身を更新",
        "        dat[k] = fa(dat[k], lazy[k]);",
        "        lazy[k] = em;",
        "    }",
        "    void update(int a, int b, M x, int k, int l, int r) {",
        "        eval(k);",
        "        if (a <= l && r <= b) {  // 完全に内側の時",
        "            lazy[k] = fm(lazy[k], x);",
        "            eval(k);",
        "        } else if (a < r && l < b) {                     // 一部区間が被る時",
        "            update(a, b, x, k * 2 + 1, l, (l + r) / 2);  // 左の子",
        "            update(a, b, x, k * 2 + 2, (l + r) / 2, r);  // 右の子",
        "            dat[k] = fx(dat[k * 2 + 1], dat[k * 2 + 2]);",
        "        }",
        "    }",
        "    void update(int a, int b, M x) { update(a, b, x, 0, 0, n); }",
        "    X query_sub(int a, int b, int k, int l, int r) {",
        "        eval(k);",
        "        if (r <= a || b <= l) {  // 完全に外側の時",
        "            return ex;",
        "        } else if (a <= l && r <= b) {  // 完全に内側の時",
        "            return dat[k];",
        "        } else {  // 一部区間が被る時",
        "            X vl = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);",
        "            X vr = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);",
        "            return fx(vl, vr);",
        "        }",
        "    }",
        "    X query(int a, int b) { return query_sub(a, b, 0, 0, n); }",
        "};",
        "  using X = ll;",
        "  using M = ll;",
        "  auto fx = [](X x1, X x2) -> X { return min(x1, x2); };",
        "  auto fa = [](X x, M m) -> X { return m; };",
        "  auto fm = [](M m1, M m2) -> M { return m2; };",
        "  int ex = numeric_limits<int>::max();",
        "  int em = numeric_limits<int>::max();",
        "  SegTreeLazy<X, M> rmq(@@, fx, fa, fm, ex, em);",
        "  rep(i,@@)rmq.set(i,0);",
        "  rmq.build();",
    ],
    "description": ""
  },
  
  "RmQ(1place update)": {
    "prefix": "RmQ",
    "body": [
        "/* RmQ：[0,n-1] について、区間ごとの最小値を管理する構造体",
        "    set(int i, T x), build(): i番目の要素をxにセット。まとめてセグ木を構築する。O(n)",
        "    update(i,x): i 番目の要素を x に更新。O(log(n))",
        "    query(a,b): [a,b) での最小の要素を取得。O(log(n))",
        "    find_rightest(a,b,x): [a,b) で x以下の要素を持つ最右位置を求める。O(log(n))",
        "    find_leftest(a,b,x): [a,b) で x以下の要素を持つ最左位置を求める。O(log(n))",
        "*/",
        "template <typename T>",
        "struct RmQ {",
        "    const T e = numeric_limits<T>::max();",
        "    function<T(T, T)> fx = [](T x1, T x2) -> T { return min(x1, x2); };",
        "    int n;",
        "    vector<T> dat;",
        "    RmQ(int n_) : n(), dat(n_ * 4, e) {",
        "        int x = 1;",
        "        while (n_ > x) {",
        "            x *= 2;",
        "        }",
        "        n = x;",
        "    }",
        "    void set(int i, T x) { dat[i + n - 1] = x; }",
        "    void build() {",
        "        for (int k = n - 2; k >= 0; k--) dat[k] = fx(dat[2 * k + 1], dat[2 * k + 2]);",
        "    }",
        "    void update(int i, T x) {",
        "        i += n - 1;",
        "        dat[i] = x;",
        "        while (i > 0) {",
        "            i = (i - 1) / 2;  // parent",
        "            dat[i] = fx(dat[i * 2 + 1], dat[i * 2 + 2]);",
        "        }",
        "    }",
        "    // the minimum element of [a,b)",
        "    T query(int a, int b) { return query_sub(a, b, 0, 0, n); }",
        "    T query_sub(int a, int b, int k, int l, int r) {",
        "        if (r <= a || b <= l) {",
        "            return e;",
        "        } else if (a <= l && r <= b) {",
        "            return dat[k];",
        "        } else {",
        "            T vl = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);",
        "            T vr = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);",
        "            return fx(vl, vr);",
        "        }",
        "    }",
        "    int find_rightest(int a, int b, T x) { return find_rightest_sub(a, b, x, 0, 0, n); }",
        "    int find_leftest(int a, int b, T x) { return find_leftest_sub(a, b, x, 0, 0, n); }",
        "    int find_rightest_sub(int a, int b, T x, int k, int l, int r) {",
        "        if (dat[k] > x || r <= a || b <= l) {  // 自分の値がxより大きい or [a,b)が[l,r)の範囲外ならreturn a-1",
        "            return a - 1;",
        "        } else if (k >= n - 1) {  // 自分が葉ならその位置をreturn",
        "            return (k - (n - 1));",
        "        } else {",
        "            int vr = find_rightest_sub(a, b, x, 2 * k + 2, (l + r) / 2, r);",
        "            if (vr != a - 1) {  // 右の部分木を見て a-1 以外ならreturn",
        "                return vr;",
        "            } else {  // 左の部分木を見て値をreturn",
        "                return find_rightest_sub(a, b, x, 2 * k + 1, l, (l + r) / 2);",
        "            }",
        "        }",
        "    }",
        "    int find_leftest_sub(int a, int b, T x, int k, int l, int r) {",
        "        if (dat[k] > x || r <= a || b <= l) {  // 自分の値がxより大きい or [a,b)が[l,r)の範囲外ならreturn b",
        "            return b;",
        "        } else if (k >= n - 1) {  // 自分が葉ならその位置をreturn",
        "            return (k - (n - 1));",
        "        } else {",
        "            int vl = find_leftest_sub(a, b, x, 2 * k + 1, l, (l + r) / 2);",
        "            if (vl != b) {  // 左の部分木を見て b 以外ならreturn",
        "                return vl;",
        "            } else {  // 右の部分木を見て値をreturn",
        "                return find_leftest_sub(a, b, x, 2 * k + 2, (l + r) / 2, r);",
        "            }",
        "        }",
        "    }",
        "};",
    ],
    "description": ""
  },
  "splitAndList": {
    "prefix": "split",
    "body": [
      "template <typename X>",
      "void splitAndList(vector<X> &d,vector<X> &a,vector<X> &b){",
      "  a.clear();",
      "  b.clear();",
      "  long long n=d.size()/2;",
      "  long long m=d.size()-n;",
      "  for(int i=0;i<(1<<n);i++){",
      "    X calc=0;",
      "    for(int j=0;j<n;j++){",
      "      if((i>>j)&1)calc+=d[j];",
      "    }",
      "    a.push_back(calc);",
      "  }",
      "  for(int i=0;i<(1<<m);i++){",
      "    X calc=0;",
      "    for(int j=0;j<m;j++){",
      "      if((i>>j)&1)calc+=d[n+j];",
      "    }",
      "    b.push_back(calc);",
      "  }",
      "  sort(a.begin(),a.end());",
      "  sort(b.begin(),b.end());",
      "}",
      "V<long long> a,b;",
      "splitAndList(d,a,b);",
      "long long ans=0;",
      "each(x,b){",
      "  auto it=upper_bound(along long(a),s-x);",
      "  if(it==a.begin())continue;",
      "  chmax(ans,*(it-1)+x);",
      "}"
    ],
    "description": ""
  },
  "rot": {
    "prefix": "rot",
    "body": [
      "template<class U>void rot(vector<U> &a){",
      "  int h=a.size(),w=a[0].size();",
      "  vector<U> pre(w,U(h,0));",
      "  swap(a,pre);",
      "  rep(i,w)rep(j,h)a[i][j]=pre[h-1-j][i];",
      "}",
    ],
    "description": ""
  },
  "ext_gcd": {
    "prefix": "gcd",
    "body": [
      "tuple<long long,long long,long long> ext_gcd(long long a,long long b){",
      "  if(a==0)return {0,1,b};",
      "  auto [X,Y,g]=ext_gcd(b%a,a);",
      "  return {-b/a*X+Y,X,g};",
      "}",
    ],
    "description": ""
  },
  "crt": {
    "prefix": "crt",
    "body": [
      "//return {b,m} x=b(mod m)",
      "tuple<long long,long long> crt(const vector<long long> &bl,const vector<long long> &ml){",
      "  long long b=0,m=1;",
      "  for(int  i=0;i<(int)bl.size();i++){",
      "    auto [x,y,g]=ext_gcd(m,ml[i]);",
      "    if((bl[i]-b)%g!=0)return {-1,-1};",
      "    long long tmp=(bl[i]-b)/g*x %(ml[i]/g);",
      "    b+=m*tmp;",
      "    m*=ml[i]/g;",
      "  }",
      "  return {(b%m+m)%m,m};",
      "}",
    ],
    "description": ""
  },
  "dijkstra": {
    "prefix": "dijk",
    "body": [
      "template<class T>",
      "tuple<V<T>,V<ll>> dijk(VV<pair<ll,T>> &g,ll s){",
      "  ll n=g.size();",
      "  priority_queue<pair<T,ll>,vector<pair<T,ll>>,greater<pair<T,ll>>> q;",
      "  q.push(mp(0,s));",
      "  vector<T> cost(n,INF);",
      "  vector<ll> pre(n,-1);",
      "  cost[s]=0;",
      "  while(q.size()!=0){",
      "    auto now=q.top();",
      "    q.pop();",
      "    if(cost[now.second]<now.first)continue;",
      "    each(x,g[now.second]){",
      "      if(cost[x.first]>cost[now.second]+x.second){",
      "        cost[x.first]=cost[now.second]+x.second;",
      "        pre[x.first]=now.second;",
      "        q.push(mp(cost[x.first],x.first));",
      "      }",
      "    }",
      "    //outv(cost);",
      "  }",
      "  //outv(cost);",
      "  return {cost,pre};",
      "}",
      "VV<pair<ll,ll>> g(n);",
      "rep(i,m){",
      "  inl(a,b,c);a--;b--;",
      "  g[a].push_back(make_pair(b,c));",
      "  g[b].push_back(make_pair(a,c));",
      "}",
    ],
    "description": ""
  },
  "tsp": {
    "prefix": "tsp",
    "body": [
      "tuple<ll,V<ll>> tsp(VV<ll> &g){",
      "  ll n=g.size();",
      "  VV<pair<ll,V<ll>>> dp(1<<n,V<pair<ll,V<ll>>>(n,{INF,V<ll>()}));",
      "  rep(i,n)dp[1<<i][i]={g[0][i],{0,i}};",
      "  rep(bit,1<<n){",
      "    rep(i,n){",
      "      if((bit&(1<<i))==0)continue;",
      "      rep(j,n){//i->j",
      "        if((bit&(1<<j))!=0)continue;",
      "        if(chmin(dp[bit|(1<<j)][j].fi,dp[bit][i].fi+g[i][j])){",
      "          dp[bit|(1<<j)][j].se=dp[bit][i].se;",
      "          dp[bit|(1<<j)][j].se.push_back(j);",
      "        }",
      "      }",
      "    }",
      "  }",
      "  return dp[(1<<n)-1][0];",
      "}",
    ],
    "description": ""
  },
  "tspPath": {
    "prefix": "tspPath",
    "body": [
      "V<pair<ll,V<ll>>> tspPath(VV<ll> &g){",
      "  ll n=g.size();",
      "  VV<pair<ll,V<ll>>> dp(1<<n,V<pair<ll,V<ll>>>(n,{INF,V<ll>(0)}));",
      "  rep(i,n)dp[1<<i][i]={0,{i}};",
      "  rep(bit,1<<n){",
      "    rep(i,n){",
      "      if((bit&(1<<i))==0)continue;",
      "      rep(j,n){//i->j",
      "        if((bit&(1<<j))!=0)continue;",
      "        if(chmin(dp[bit|(1<<j)][j].fi,dp[bit][i].fi+g[i][j])){",
      "          dp[bit|(1<<j)][j].se=dp[bit][i].se;",
      "          dp[bit|(1<<j)][j].se.push_back(j);",
      "        }",
      "      }",
      "    }",
      "  }",
      "  return dp[(1<<n)-1];",
      "}",
    ],
    "description": ""
  },
  "trie": {
    "prefix": "trie",
    "body": [
      "/* Trie 木： 文字の種類(char_size)、int型で0に対応する文字(base)",
      "insert(word): 単語 word を Trie 木に挿入する",
      "search(word): 単語 word が Trie 木にあるか判定する",
      "start_with(prefix):  prefix が一致する単語が Trie 木にあるか判定する",
      "count(): 挿入した単語の数を返す",
      "size(): Trie 木の頂点数を返す",
      "計算量：insert, search ともに O(M)（Mは単語の長さ）",
      "*/",
      "template <int char_size, int base>",
      "struct Trie {",
      "  struct Node {            // 頂点を表す構造体",
      "    vector<int> next;    // 子の頂点番号を格納。存在しなければ-1",
      "    vector<int> accept;  // 末端がこの頂点になる単語の word_id を保存",
      "    int c;               // base からの間隔をint型で表現したもの",
      "    int common;          // いくつの単語がこの頂点を共有しているか",
      "    Node(int c_) : c(c_), common(0) {",
      "    next.assign(char_size, -1);",
      "    }",
      "  };",
      "  vector<Node> nodes;  // trie 木本体",
      "  int root;",
      "  Trie() : root(0) {",
      "    nodes.push_back(Node(root));",
      "  }",
      "  // 単語の挿入",
      "  void insert(const string &word, int word_id) {",
      "    int node_id = 0;",
      "    for (int i = 0; i < (int)word.size(); i++) {",
      "      int c = (int)(word[i] - base);",
      "      int &next_id = nodes[node_id].next[c];",
      "      if (next_id == -1) {  // 次の頂点が存在しなければ追加",
      "        next_id = (int)nodes.size();",
      "        nodes.push_back(Node(c));",
      "      }",
      "      ++nodes[node_id].common;",
      "      node_id = next_id;",
      "    }",
      "    ++nodes[node_id].common;",
      "    nodes[node_id].accept.push_back(word_id);",
      "  }",
      "  void insert(const string &word) {",
      "    insert(word, nodes[0].common);",
      "  }",
      "  // 単語とprefixの検索",
      "  bool search(const string &word, bool prefix = false) {",
      "    int node_id = 0;",
      "    for (int i = 0; i < (int)word.size(); i++) {",
      "    int c = (int)(word[i] - base);",
      "    int &next_id = nodes[node_id].next[c];",
      "    if (next_id == -1) {  // 次の頂点が存在しなければ終了",
      "      return false;",
      "    }",
      "    node_id = next_id;",
      "    }",
      "    return (prefix) ? true : nodes[node_id].accept.size() > 0;",
      "  }",
      "  // prefix を持つ単語が存在するかの検索",
      "  bool start_with(const string &prefix) {",
      "    return search(prefix, true);",
      "  }",
      "  // 挿入した単語の数",
      "  int count() const {",
      "    return (nodes[0].common);",
      "  }",
      "  // Trie木のノード数",
      "  int size() const {",
      "    return ((int)nodes.size());",
      "  }",
      "};",
      "",
      "  Trie<26, 'A'> trie;",
    ],
    "description": ""
  },
  "dynamicUnionFind": {
    "prefix": "dynamicUnionFind",
    "body": [
        "//辺追加・削除 O(log^2(N))",
        "//link判定 O(logN)",
        "template<typename T>",
        "class dynamic_connectivity{",
        "    class euler_tour_tree{",
        "        public:",
        "        struct node;",
        "        using np=node*;",
        "        using lint=long long;",
        "        struct node{",
        "            np ch[2]={nullptr,nullptr};",
        "            np p=nullptr;",
        "            int l,r,sz;",
        "            T val=et,sum=et;",
        "            bool exact;",
        "            bool child_exact;",
        "            bool edge_connected=0;",
        "            bool child_edge_connected=0;",
        "            node(){}",
        "            node(int l,int r):l(l),r(r),sz(l==r),exact(l<r),child_exact(l<r){}",
        "            bool is_root() {",
        "                return !p;",
        "            }",
        "        };",
        "        vector<unordered_map<int,np>>ptr;",
        "        np get_node(int l,int r){",
        "            if(ptr[l].find(r)==ptr[l].end())ptr[l][r]=new node(l,r);",
        "            return ptr[l][r];",
        "        }",
        "        np root(np t){",
        "            if(!t)return t;",
        "            while(t->p)t=t->p;",
        "            return t;",
        "        }",
        "        bool same(np s,np t){",
        "            if(s)splay(s);",
        "            if(t)splay(t);",
        "            return root(s)==root(t);",
        "        }",
        "        np reroot(np t){",
        "            auto s=split(t);",
        "            return merge(s.second,s.first);",
        "        }",
        "        pair<np,np> split(np s){",
        "            splay(s);",
        "            np t=s->ch[0];",
        "            if(t)t->p=nullptr;",
        "            s->ch[0]=nullptr;",
        "            return {t,update(s)};",
        "        }",
        "        pair<np,np> split2(np s){",
        "            splay(s);",
        "            np t=s->ch[0];",
        "            np u=s->ch[1];",
        "            if(t)t->p=nullptr;",
        "            s->ch[0]=nullptr;",
        "            if(u)u->p=nullptr;",
        "            s->ch[1]=nullptr;",
        "            return {t,u};",
        "        }",
        "        tuple<np,np,np> split(np s,np t){",
        "            auto u=split2(s);",
        "            if(same(u.first,t)){",
        "                auto r=split2(t);",
        "                return make_tuple(r.first,r.second,u.second);",
        "            }else{",
        "                auto r=split2(t);",
        "                return make_tuple(u.first,r.first,r.second);",
        "            }",
        "        }",
        "        template<typename First, typename... Rest>",
        "        np merge(First s,Rest... t){",
        "            return merge(s,merge(t...));",
        "        }",
        "        np merge(np s,np t){",
        "            if(!s)return t;",
        "            if(!t)return s;",
        "            while(s->ch[1])s=s->ch[1];",
        "            splay(s);",
        "            s->ch[1]=t;",
        "            if(t)t->p=s;",
        "            return update(s);",
        "        }",
        "        int size(np t){return t?t->sz:0;}",
        "        np update(np t){",
        "            t->sum=et;",
        "            if(t->ch[0])t->sum=fn(t->sum,t->ch[0]->sum);",
        "            if(t->l==t->r)t->sum=fn(t->sum,t->val);",
        "            if(t->ch[1])t->sum=fn(t->sum,t->ch[1]->sum);",
        "            t->sz=size(t->ch[0])+(t->l==t->r)+size(t->ch[1]);",
        "            t->child_edge_connected=(t->ch[0]?t->ch[0]->child_edge_connected:0)|(t->edge_connected)|(t->ch[1]?t->ch[1]->child_edge_connected:0);",
        "            t->child_exact=(t->ch[0]?t->ch[0]->child_exact:0)|(t->exact)|(t->ch[1]?t->ch[1]->child_exact:0);",
        "            return t;",
        "        }",
        "        void push(np t){",
        "            //遅延評価予定",
        "        }",
        "        void rot(np t,bool b){",
        "            np x=t->p,y=x->p;",
        "            if((x->ch[1-b]=t->ch[b]))t->ch[b]->p=x;",
        "            t->ch[b]=x,x->p=t;",
        "            update(x);update(t);",
        "            if((t->p=y)){",
        "                if(y->ch[0]==x)y->ch[0]=t;",
        "                if(y->ch[1]==x)y->ch[1]=t;",
        "                update(y);",
        "            }",
        "        }",
        "        void splay(np t){",
        "            push(t);",
        "            while(!t->is_root()){",
        "                np q=t->p;",
        "                if(q->is_root()){",
        "                    push(q), push(t);",
        "                    rot(t,q->ch[0]==t);",
        "                }else{",
        "                    np r=q->p;",
        "                    push(r), push(q), push(t);",
        "                    bool b=r->ch[0]==q;",
        "                    if(q->ch[1-b]==t)rot(q,b),rot(t,b);",
        "                    else rot(t,1-b),rot(t,b);",
        "                }",
        "            }",
        "        }",
        "        void debug_(np t){",
        "            if(!t)return;",
        "            debug_(t->ch[0]);",
        "            cerr<<t->l<<\"-\"<<t->r<<\" \";",
        "            debug_(t->ch[1]);",
        "        }",
        "        public:",
        "        euler_tour_tree(){}",
        "        euler_tour_tree(int sz){",
        "            ptr.resize(sz);",
        "            for(int i=0;i<sz;i++)ptr[i][i]=new node(i,i);",
        "        }",
        "        int size(int s){",
        "            np t=get_node(s,s);",
        "            splay(t);",
        "            return t->sz;",
        "        }",
        "        bool same(int s,int t){",
        "            return same(get_node(s,s),get_node(t,t));",
        "        }",
        "        void set_size(int sz){",
        "            ptr.resize(sz);",
        "            for(int i=0;i<sz;i++)ptr[i][i]=new node(i,i);",
        "        }",
        "        void update(int s,T x){",
        "            np t=get_node(s,s);",
        "            splay(t);",
        "            t->val=fn(t->val,x);",
        "            update(t);",
        "        }",
        "        void edge_update(int s,auto g){",
        "            np t=get_node(s,s);",
        "            splay(t);",
        "            function<void(np)>dfs=[&](np t){",
        "                assert(t);",
        "                if(t->l<t->r&&t->exact){",
        "                    splay(t);",
        "                    t->exact=0;",
        "                    update(t);",
        "                    g(t->l,t->r);",
        "                    return;",
        "                }",
        "                if(t->ch[0]&&t->ch[0]->child_exact)dfs(t->ch[0]);",
        "                else dfs(t->ch[1]);",
        "            };",
        "            while(t&&t->child_exact){",
        "                dfs(t);",
        "                splay(t);",
        "            }",
        "        }",
        "        bool try_reconnect(int s,auto f){",
        "            np t=get_node(s,s);",
        "            splay(t);",
        "            function<bool(np)>dfs=[&](np t)->bool{",
        "                assert(t);",
        "                if(t->edge_connected){",
        "                    splay(t);",
        "                    return f(t->l);",
        "                }",
        "                if(t->ch[0]&&t->ch[0]->child_edge_connected)return dfs(t->ch[0]);",
        "                else return dfs(t->ch[1]);",
        "            };",
        "            while(t->child_edge_connected){",
        "                if(dfs(t))return 1;",
        "                splay(t);",
        "            }",
        "            return 0;",
        "        }",
        "        void edge_connected_update(int s,bool b){",
        "            np t=get_node(s,s);",
        "            splay(t);",
        "            t->edge_connected=b;",
        "            update(t);",
        "        }",
        "        bool link(int l,int r){",
        "            if(same(l,r))return 0;",
        "            merge(reroot(get_node(l,l)),get_node(l,r),reroot(get_node(r,r)),get_node(r,l));",
        "            return 1;",
        "        }",
        "        bool cut(int l,int r){",
        "            if(ptr[l].find(r)==ptr[l].end())return 0;",
        "            np s,t,u;",
        "            tie(s,t,u)=split(get_node(l,r),get_node(r,l));",
        "            merge(s,u);",
        "            np p=ptr[l][r];",
        "            np q=ptr[r][l];",
        "            ptr[l].erase(r);",
        "            ptr[r].erase(l);",
        "            delete p;delete q;",
        "            return 1;",
        "        }",
        "        T get_sum(int p,int v){",
        "            cut(p,v);",
        "            np t=get_node(v,v);",
        "            splay(t);",
        "            T res=t->sum;",
        "            link(p,v);",
        "            return res;",
        "        }",
        "        T get_sum(int s){",
        "            np t=get_node(s,s);",
        "            splay(t);",
        "            return t->sum;",
        "        }",
        "    };",
        "    int dep=1;",
        "    vector<euler_tour_tree> ett;",
        "    vector<vector<unordered_set<int>>>edges;",
        "    int sz;",
        "    public:",
        "    dynamic_connectivity(int sz):sz(sz){",
        "        ett.emplace_back(sz);",
        "        edges.emplace_back(sz);",
        "    }",
        "    bool link(int s,int t){",
        "        if(s==t)return 0;",
        "        if(ett[0].link(s,t))return 1;",
        "        edges[0][s].insert(t);",
        "        edges[0][t].insert(s);",
        "        if(edges[0][s].size()==1)ett[0].edge_connected_update(s,1);",
        "        if(edges[0][t].size()==1)ett[0].edge_connected_update(t,1);",
        "        return 0;",
        "    }",
        "    bool same(int s,int t){",
        "        return ett[0].same(s,t);",
        "    }",
        "    int size(int s){",
        "        return ett[0].size(s);",
        "    }",
        "    vector<int>get_vertex(int s){",
        "        return ett[0].vertex_list(s);",
        "    }",
        "    void update(int s,T x){",
        "        ett[0].update(s,x);",
        "    }",
        "    T get_sum(int s){",
        "        return ett[0].get_sum(s);",
        "    }",
        "    bool cut(int s,int t){",
        "        if(s==t)return 0;",
        "        for(int i=0;i<dep;i++){",
        "            edges[i][s].erase(t);",
        "            edges[i][t].erase(s);",
        "            if(edges[i][s].size()==0)ett[i].edge_connected_update(s,0);",
        "            if(edges[i][t].size()==0)ett[i].edge_connected_update(t,0);",
        "        }",
        "        for(int i=dep-1;i>=0;i--){",
        "            if(ett[i].cut(s,t)){",
        "                if(dep-1==i){",
        "                    dep++;",
        "                    ett.emplace_back(sz);",
        "                    edges.emplace_back(sz);",
        "                }",
        "                return !try_reconnect(s,t,i);",
        "            }",
        "        }",
        "        return 0;",
        "    }",
        "    bool try_reconnect(int s,int t,int k){",
        "        for(int i=0;i<k;i++){",
        "            ett[i].cut(s,t);",
        "        }",
        "        for(int i=k;i>=0;i--){",
        "            if(ett[i].size(s)>ett[i].size(t))swap(s,t);",
        "            auto g=[&](int s,int t){ett[i+1].link(s,t);};",
        "            ett[i].edge_update(s,g);",
        "            auto f=[&](int x)->bool{",
        "                for(auto itr=edges[i][x].begin();itr!=edges[i][x].end();){",
        "                    auto y=*itr;",
        "                    itr=edges[i][x].erase(itr);",
        "                    edges[i][y].erase(x);",
        "                    if(edges[i][x].size()==0)ett[i].edge_connected_update(x,0);",
        "                    if(edges[i][y].size()==0)ett[i].edge_connected_update(y,0);",
        "                    if(ett[i].same(x,y)){",
        "                        edges[i+1][x].insert(y);",
        "                        edges[i+1][y].insert(x);",
        "                        if(edges[i+1][x].size()==1)ett[i+1].edge_connected_update(x,1);",
        "                        if(edges[i+1][y].size()==1)ett[i+1].edge_connected_update(y,1);",
        "                    }else{",
        "                        for(int j=0;j<=i;j++){",
        "                            ett[j].link(x,y);",
        "                        }",
        "                        return 1;",
        "                    }",
        "                }",
        "                return 0;",
        "            };",
        "            if(ett[i].try_reconnect(s,f))return 1;",
        "        }",
        "        return 0;",
        "    }",
        "    constexpr static T et=T();",
        "    constexpr static T fn(T s,T t){",
        "        return s+t;",
        "    }",
        "};",
    ],
    "description": ""
  },
  "scc": {
    "prefix": "scc",
    "body": [
        "template<typename T>",
        "struct strongly_connected_components {",
        "    const T &g;",
        "    vector<vector<int>> gg, rg;",
        "    vector<int> comp, order, used;",
        "",
        "    strongly_connected_components(T &g):",
        "        g(g), gg(g.size()), rg(g.size()), comp(g.size(), -1), used(g.size())",
        "    {",
        "        for(int i=0;i<(int)g.size();i++){",
        "            for(auto &e:g[i]){",
        "                gg[i].emplace_back(e);",
        "                rg[e].emplace_back(i);",
        "            }",
        "        }",
        "    }",
        "    int operator[](int k) {",
        "        return comp[k];",
        "    }",
        "    void dfs(int idx) {",
        "        if(used[idx])return;",
        "        used[idx]=true;",
        "        for(int to:gg[idx])dfs(to);",
        "        order.push_back(idx);",
        "    }",
        "    void rdfs(int idx, int cnt) {",
        "        if(comp[idx]!=-1)return;",
        "        comp[idx]=cnt;",
        "        for(int to:rg[idx])rdfs(to, cnt);",
        "    }",
        "    T build() {",
        "        for(int i=0;i<(int)gg.size();i++) dfs(i);",
        "        reverse(order.begin(),order.end());",
        "        int ptr = 0;",
        "        for(int i : order) if(comp[i] == -1) rdfs(i, ptr), ptr++;",
        "",
        "        T t(ptr);",
        "        for(int i = 0; i < (int)g.size(); i++) {",
        "            for(auto &to : g[i]) {",
        "                int x = comp[i], y = comp[to];",
        "                if(x == y) continue;",
        "                t[x].push_back(y);",
        "            }",
        "        }",
        "        return t;",
        "    }",
        "};",
    ],
    "description": ""
  },

}